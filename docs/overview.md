# Overview

## Lexing and parsing.

The parser is a simple recursive descend parser. Pratt parsing is used for expressios. The parser holds almost no intertal state apart from the stream of tokens generated by the preprocessor. The tokens produced by lexers are only used by parser and discarded afterwards.

To identify source code locations (source, line, char), location ID is generated by source manager for each token and stored in syntax tree. Full location data and source code can be later retrieved from the source manager. (TODO: only store location data used in syntax tree?)

## Syntax tree

The tree is just a data structure, most of the work on it is done in AST visitors. Each node implements `child_num()` and `child(n)` functions that allow to traverse the tree in a uniform manner (see ast::RecVisitor). Expression nodes can also be visited by `ast::ExprVisitor` to produce `ExprRes` expression result (type, value, error code).

## Types

Type objects are responsible for knowing which other types they can be casted/converted to, creating compound types, constructing default values. Non-class types also directly implement casts and operators.

Aliases are considered separate types but proxy most method calls to the underlying type for convenience.
```
// typedef Unsigned(8) Foo;
assert(foo->is_alias());
assert(foo->is_prim()); // primitive type

auto int_type = _program->builtins().int_type(10);
assert(foo->is_impl_castable_to(int_type));
```

Canonical types are types not associated with typedefs, e.g.
```
// typedef Unsigned(8) Foo;
// typedef Foo FooList[10];
// typedef FooList Bar;
auto canon = bar->canon(); // Unsigned(8)[10]
assert(canon->item_type() == bar->item_type()->canon());
```

## Values

Values have only 2 categories -- lvalue and rvalue, lvalues additionally have `is_xvalue` flag for temporaries (so lvalue is glvalue in C++ terms).

Objects and arrays are represented by `Data` (rvalue) and `DataView` (lvalue) which correspond to `Storage` and `Ptr` in ULAM, `DataView` holding pointer to `Data`, type and offset of value in `Data`, offset of Atom holding the value etc. `Bits` class used for storage is dynamically-sized version of `MFM::BitVector`.

rvalues known at compile-time are marked as `is_consteval`.

`LValue` and `RValue` classes (and `Value` variant) implement some convenience functions for e.g. accessing properties of an object that may not be safe or appropriate to call on all values. Callers are supposed to check if value is empty and use type information to decide how to handle values they did not directly create.

## Scopes and type/constant resolution

ULAM class definitions can be mutually dependent, which makes them impossible to fully resolve in a single pass in general. For example:
```
quark A {
  typedef B.U R;
  typedef Int S;
}
quark B {
  typedef A.S T;
  typedef Int U;
}
```
To handle such situations, libulam uses a persistent data structure for module and class scopes (`PersScope`) and assignes a version number to each definition in them. When resolving a definition, the exact scope version can be used via `PersScopeView` object (see `sema::Resolver`).

## Resolving inter-module dependencies

`sema::Init` is responsible for creating `Program` object, adding modules, and populating them from AST. Unseen types are added to a list of module dependencies. After all modules are populated, the dependencies can be hopefully found by name in a list of public symbols (classes and class templates) exported from all modules and imported in to dependent modules by adding it to its "module environment" scope (a parent of main module scope).

As an implementation detail, classes/templates that are used before being defined in same module are resolved in the same way.

